# Vex CMS Implementation Plan

This document provides a step-by-step guide to bootstrap the Vex CMS project, with the goal of:
1. Setting up the monorepo structure with minimal packages needed initially
2. Creating a testable admin shell UI
3. Building a test app in `apps/` to verify the installation flow
4. Eventually creating a `create-vexcms` CLI that extends create-z3-app

---

## Strategy: Incremental Build Approach

We will NOT create all folders upfront. Instead, we build incrementally:

1. **Phase A**: Minimal monorepo with just `@vexcms/core` and `@vexcms/admin`
2. **Phase B**: Test app (`apps/test-app`) to verify installation
3. **Phase C**: Add features incrementally, testing each as we go
4. **Phase D**: Build `create-vexcms` CLI once installation flow is validated

---

## How Vex CMS Will Be Used (Target Installation Flow)

When a user wants to use Vex CMS, they will:

```bash
# Option 1: Add to existing Next.js + Convex project
pnpm add @vexcms/core @vexcms/convex @vexcms/admin

# Option 2: Use CLI to scaffold new project (future)
pnpm create vexcms@latest
```

### Files Added to User's Project

```
user-project/
├── vex.config.ts              # User creates this (schema definitions)
├── convex/
│   ├── vex.schema.ts          # AUTO-GENERATED by `vex sync` (DO NOT EDIT)
│   ├── schema.ts              # User-owned, imports from vex.schema.ts
│   └── vex/
│       └── index.ts           # Admin CRUD handlers (createVexHandlers)
├── src/
│   └── app/
│       └── admin/             # Admin panel routes
│           ├── [[...path]]/
│           │   └── page.tsx   # Catch-all admin route
│           └── layout.tsx     # Admin layout
└── ...
```

### Two-File Schema Approach

Vex uses a two-file schema approach to allow automatic updates without overwriting user customizations:

1. **`convex/vex.schema.ts`** — Auto-generated by `vex sync`, regenerated on config changes
2. **`convex/schema.ts`** — User-owned, imports from vex.schema.ts, can extend with custom tables

This enables hot-reloading during development:
- Run `vex sync --watch` alongside `convex dev`
- Changes to `vex.config.ts` automatically regenerate `vex.schema.ts`
- User's custom tables and indexes in `schema.ts` are preserved

---

## Phase A: Minimal Monorepo Setup

### Goal
Set up the bare minimum structure to start building and testing the admin UI.

### Step A.1: Initialize Root

Create the Vex CMS monorepo root:

```bash
# Create directory (assuming starting fresh)
mkdir vexcms && cd vexcms

# Initialize pnpm
pnpm init

# Create workspace config
cat > pnpm-workspace.yaml << 'EOF'
packages:
  - "packages/*"
  - "apps/*"
EOF

# Create .npmrc
cat > .npmrc << 'EOF'
shamefully-hoist=true
save-exact=true
strict-peer-dependencies=false
EOF

# Install root dev dependencies
pnpm add -D turbo prettier typescript -w
```

### Step A.2: Create Shared Configs

```bash
mkdir -p packages/tsconfig
```

**packages/tsconfig/package.json**
```json
{
  "name": "@vexcms/tsconfig",
  "version": "0.0.0",
  "private": true,
  "files": ["*.json"]
}
```

**packages/tsconfig/base.json**
```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "verbatimModuleSyntax": true,
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "skipLibCheck": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "exclude": ["node_modules", "dist"]
}
```

**packages/tsconfig/react-library.json**
```json
{
  "extends": "./base.json",
  "compilerOptions": {
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx"
  }
}
```

**packages/tsconfig/nextjs.json**
```json
{
  "extends": "./base.json",
  "compilerOptions": {
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "jsx": "preserve",
    "allowJs": true,
    "noEmit": true,
    "incremental": true,
    "plugins": [{ "name": "next" }]
  }
}
```

### Step A.3: Create @vexcms/core (Minimal)

For now, we only need the basic types. Field implementations come later.

```bash
mkdir -p packages/core/src
```

**packages/core/package.json**
```json
{
  "name": "@vexcms/core",
  "version": "0.0.0",
  "type": "module",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "clean": "rm -rf dist",
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "@vexcms/tsconfig": "workspace:*",
    "tsup": "^8.0.0",
    "typescript": "^5.4.0"
  },
  "publishConfig": {
    "access": "public"
  }
}
```

**packages/core/tsconfig.json**
```json
{
  "extends": "@vexcms/tsconfig/base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}
```

**packages/core/tsup.config.ts**
```typescript
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm'],
  dts: true,
  sourcemap: true,
  clean: true,
});
```

**packages/core/src/index.ts**
```typescript
// Minimal exports for Phase A
// Full field system comes in Phase C

export interface VexConfig {
  collections: Record<string, unknown>;
  globals?: Record<string, unknown>;
  admin?: {
    basePath?: string;
  };
}

export function defineConfig(config: VexConfig): VexConfig {
  return config;
}

// Placeholder for future field types
export type { VexConfig as Config };
```

### Step A.4: Create @vexcms/admin (Layout Only)

This is the main focus for Phase A - a working admin shell.

```bash
mkdir -p packages/admin/src/{components,hooks,next}
```

**packages/admin/package.json**
```json
{
  "name": "@vexcms/admin",
  "version": "0.0.0",
  "type": "module",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    },
    "./next": {
      "import": "./dist/next/index.js",
      "types": "./dist/next/index.d.ts"
    }
  },
  "files": ["dist"],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "clean": "rm -rf dist",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@vexcms/core": "workspace:*"
  },
  "peerDependencies": {
    "next": ">=14.0.0",
    "react": ">=18.0.0",
    "react-dom": ">=18.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@vexcms/tsconfig": "workspace:*",
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "tsup": "^8.0.0",
    "typescript": "^5.4.0"
  },
  "publishConfig": {
    "access": "public"
  }
}
```

**packages/admin/tsconfig.json**
```json
{
  "extends": "@vexcms/tsconfig/react-library.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src"]
}
```

**packages/admin/tsup.config.ts**
```typescript
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts', 'src/next/index.ts'],
  format: ['esm'],
  dts: true,
  sourcemap: true,
  clean: true,
  external: ['react', 'react-dom', 'next'],
});
```

**packages/admin/src/index.ts**
```typescript
// Main exports (hooks, components)
export * from './components';
export * from './hooks';
```

**packages/admin/src/components/index.ts**
```typescript
export { Layout } from './Layout';
export { Sidebar } from './Sidebar';
export { Header } from './Header';
```

**packages/admin/src/components/Layout.tsx**
```typescript
import * as React from 'react';
import { Sidebar } from './Sidebar';
import { Header } from './Header';

interface LayoutProps {
  children: React.ReactNode;
  basePath?: string;
}

export function Layout({ children, basePath = '/admin' }: LayoutProps) {
  return (
    <div className="vex-shell">
      <Sidebar basePath={basePath} />
      <div className="vex-main">
        <Header />
        <main className="vex-content">
          {children}
        </main>
      </div>
    </div>
  );
}
```

**packages/admin/src/components/Sidebar.tsx**
```typescript
import * as React from 'react';

interface SidebarProps {
  basePath: string;
}

export function Sidebar({ basePath }: SidebarProps) {
  return (
    <aside className="vex-sidebar">
      <div className="vex-sidebar-header">
        <span className="vex-logo">Vex CMS</span>
      </div>
      <nav className="vex-nav">
        <a href={basePath} className="vex-nav-item">
          Dashboard
        </a>
        {/* Collections will be rendered dynamically */}
      </nav>
    </aside>
  );
}
```

**packages/admin/src/components/Header.tsx**
```typescript
import * as React from 'react';

export function Header() {
  return (
    <header className="vex-header">
      <div className="vex-header-content">
        {/* User menu will go here */}
      </div>
    </header>
  );
}
```

**packages/admin/src/hooks/index.ts**
```typescript
// Hooks will be added incrementally
export {};
```

**packages/admin/src/next/index.ts**
```typescript
// Next.js specific exports
export { createVexAdmin } from './createVexAdmin';
export { VexAdminProvider } from './VexAdminProvider';
```

**packages/admin/src/next/createVexAdmin.tsx**
```typescript
import * as React from 'react';
import type { VexConfig } from '@vexcms/core';
import { Layout } from '../components/Layout';

interface CreateVexAdminOptions {
  config: VexConfig;
  basePath?: string;
}

export function createVexAdmin(options: CreateVexAdminOptions) {
  const { config, basePath = '/admin' } = options;

  function AdminLayout({ children }: { children: React.ReactNode }) {
    return (
      <Layout basePath={basePath}>
        {children}
      </Layout>
    );
  }

  function AdminPage() {
    return (
      <div>
        <h1>Welcome to Vex CMS</h1>
        <p>Collections: {Object.keys(config.collections).length}</p>
      </div>
    );
  }

  return {
    AdminLayout,
    AdminPage,
    config,
    basePath,
  };
}
```

**packages/admin/src/next/VexAdminProvider.tsx**
```typescript
'use client';

import * as React from 'react';
import type { VexConfig } from '@vexcms/core';

interface VexAdminContextValue {
  config: VexConfig;
  basePath: string;
}

const VexAdminContext = React.createContext<VexAdminContextValue | null>(null);

interface VexAdminProviderProps {
  children: React.ReactNode;
  config: VexConfig;
  basePath?: string;
}

export function VexAdminProvider({
  children,
  config,
  basePath = '/admin'
}: VexAdminProviderProps) {
  return (
    <VexAdminContext.Provider value={{ config, basePath }}>
      {children}
    </VexAdminContext.Provider>
  );
}

export function useVexAdmin() {
  const context = React.useContext(VexAdminContext);
  if (!context) {
    throw new Error('useVexAdmin must be used within a VexAdminProvider');
  }
  return context;
}
```

### Step A.5: Create Root turbo.json

**turbo.json**
```json
{
  "$schema": "https://turbo.build/schema.json",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "typecheck": {
      "dependsOn": ["^build"]
    },
    "clean": {
      "cache": false
    }
  }
}
```

### Step A.6: Root package.json

**package.json**
```json
{
  "name": "vexcms",
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "typecheck": "turbo run typecheck",
    "clean": "turbo run clean && rm -rf node_modules"
  },
  "devDependencies": {
    "@vexcms/tsconfig": "workspace:*",
    "prettier": "^3.2.0",
    "turbo": "^2.0.0",
    "typescript": "^5.4.0"
  },
  "packageManager": "pnpm@9.0.0",
  "engines": {
    "node": ">=20.0.0"
  }
}
```

### Step A.7: Verify Build

```bash
# Install dependencies
pnpm install

# Build packages
pnpm build

# Should see:
# packages/core: dist/ created
# packages/admin: dist/ created
```

---

## Phase B: Test App Setup

### Goal
Create a test application in `apps/` that uses the Vex packages to verify the installation flow.

### Step B.1: Create Test App (Fork of z3 Template)

The test app should be similar to what `create-z3-app` generates, but with Vex CMS added.

```bash
mkdir -p apps/test-app
```

We'll use create-z3-app as a base, then add Vex:

```bash
# Option 1: Clone create-z3-app template
cd apps
pnpm create z3@latest test-app
# Select: Next.js, email/password auth, no oauth for simplicity

# Then add workspace deps
cd test-app
# Edit package.json to add:
# "@vexcms/core": "workspace:*",
# "@vexcms/admin": "workspace:*"
```

### Step B.2: Add Vex Config to Test App

**apps/test-app/vex.config.ts**
```typescript
import { defineConfig } from '@vexcms/core';

export default defineConfig({
  collections: {
    posts: {
      // Will be filled in when field system is built
    },
    users: {
      // Will be filled in
    },
  },
  admin: {
    basePath: '/admin',
  },
});
```

### Step B.3: Add Admin Routes

**apps/test-app/src/app/admin/layout.tsx**
```typescript
import { createVexAdmin } from '@vexcms/admin/next';
import vexConfig from '../../../vex.config';

const { AdminLayout } = createVexAdmin({ config: vexConfig });

export default function Layout({ children }: { children: React.ReactNode }) {
  return <AdminLayout>{children}</AdminLayout>;
}
```

**apps/test-app/src/app/admin/page.tsx**
```typescript
import { createVexAdmin } from '@vexcms/admin/next';
import vexConfig from '../../../vex.config';

const { AdminPage } = createVexAdmin({ config: vexConfig });

export default AdminPage;
```

### Step B.4: Update Test App package.json

Add workspace dependencies:

```json
{
  "dependencies": {
    "@vexcms/core": "workspace:*",
    "@vexcms/admin": "workspace:*",
    // ... existing z3 deps
  }
}
```

### Step B.5: Verify Test App

```bash
# From root
pnpm install
pnpm build
pnpm --filter test-app dev

# Visit http://localhost:3000/admin
# Should see Vex CMS shell
```

---

## Phase C: Incremental Feature Development

Once Phase A and B are working, add features one at a time:

### C.1: Field System (05-schema-field-system-spec.md)
- Add `text()`, `number()`, `select()` etc. to `@vexcms/core`
- Update test app vex.config.ts with real field definitions

### C.2: Convex Integration (06-convex-integration-spec.md)
- Create `@vexcms/convex` package
- Add schema generation
- Add admin handlers

### C.3: Admin UI Components (09-custom-admin-components-spec.md)
- Add form components to `@vexcms/admin`
- Add `useField`, `useForm` hooks
- Test with Playwright in `apps/admin-test`

### C.4: Auth Integration (04-auth-adapter-spec.md)
- Add Better Auth adapter
- Integrate with existing z3 auth setup

---

## Phase D: Create-VexCMS CLI

Once the installation flow is validated, build a CLI similar to create-z3-app:

### CLI Structure

```
packages/create-vexcms/
├── src/
│   ├── index.ts           # CLI entry
│   ├── prompts.ts         # Interactive prompts
│   └── installers/
│       ├── vex.ts         # Add Vex to existing project
│       └── full.ts        # Scaffold full project
├── templates/
│   └── nextjs/            # Full project template
├── package.json
└── tsconfig.json
```

### CLI Options

```bash
# Scaffold new project (uses z3 template + Vex)
pnpm create vexcms@latest my-project

# Add Vex to existing project
pnpm create vexcms@latest --add-to-existing
```

### Integration with create-z3-app

The CLI can either:
1. **Fork z3**: Maintain our own template (more control, more maintenance)
2. **Extend z3**: Call create-z3 first, then add Vex on top (less maintenance)
3. **Collaborate**: Add a flag to create-z3 for Vex CMS (requires upstream buy-in)

**Recommendation**: Start with Option 2 (extend), move to Option 1 if needed.

---

## Folder Structure After Phase B

```
vexcms/
├── apps/
│   └── test-app/                    # z3 template + Vex
│       ├── convex/
│       ├── src/
│       │   └── app/
│       │       ├── admin/           # Vex admin routes
│       │       │   ├── layout.tsx
│       │       │   └── page.tsx
│       │       └── ...
│       ├── vex.config.ts            # Vex configuration
│       └── package.json
│
├── packages/
│   ├── core/                        # @vexcms/core (minimal)
│   │   ├── src/
│   │   │   └── index.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   ├── admin/                       # @vexcms/admin (shell only)
│   │   ├── src/
│   │   │   ├── components/
│   │   │   │   ├── Layout.tsx
│   │   │   │   ├── Sidebar.tsx
│   │   │   │   └── Header.tsx
│   │   │   ├── hooks/
│   │   │   ├── next/
│   │   │   │   ├── createVexAdmin.tsx
│   │   │   │   └── VexAdminProvider.tsx
│   │   │   └── index.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   │
│   └── tsconfig/                    # @vexcms/tsconfig
│       ├── base.json
│       ├── react-library.json
│       ├── nextjs.json
│       └── package.json
│
├── turbo.json
├── pnpm-workspace.yaml
├── package.json
└── .npmrc
```

---

## Next Steps After This Plan

1. **Execute Phase A**: Create the minimal monorepo structure
2. **Execute Phase B**: Set up test-app with z3 base + Vex admin routes
3. **Verify admin shell renders** at `/admin`
4. **Add Playwright tests** for admin UI (01-testing-infrastructure-spec.md)
5. **Iterate on admin shell UI** with styling (Tailwind, shadcn)
6. **Begin Phase C**: Implement field system

---

## Integration with create-z3-app Repository

Based on analysis of https://github.com/ianyimi/create-z3-app:

### What z3 Provides (That Vex Will Use)
- Next.js App Router setup
- Convex integration with schema
- Better Auth (email/password + OAuth)
- shadcn/ui components
- Tailwind CSS
- TypeScript configuration

### What Vex Adds
- `vex.config.ts` - Schema definitions with fields
- `/admin/*` routes - Admin panel
- `@vexcms/*` packages - Admin UI, handlers, field types
- Convex handlers for admin CRUD operations
- Version/draft workflow (later)

### Files Vex Creates/Modifies in z3 Project

**Created by `vex sync`:**
1. **convex/vex.schema.ts** - Auto-generated table definitions (DO NOT EDIT)
2. **convex/schema.ts** - User-owned, imports from vex.schema.ts (created if not exists, updated if `autoUpdateSchema: true`)

**Created manually or by future CLI:**
3. **vex.config.ts** - Root config file with collections
4. **src/app/admin/** - Admin routes
5. **convex/vex/index.ts** - Admin CRUD handlers

### Future CLI Branch
Once validated, create a `vexcms` branch in create-z3-app that:
1. Adds `@vexcms/*` packages to dependencies
2. Creates admin route files
3. Creates starter vex.config.ts
4. Runs `vex sync` to generate schema files

---

## Summary

| Phase | Goal | Packages Created | Validation |
|-------|------|-----------------|------------|
| A | Monorepo + minimal packages | @vexcms/core, @vexcms/admin, @vexcms/tsconfig | `pnpm build` works |
| B | Test app with admin shell | apps/test-app | Admin shell visible at /admin |
| C | Feature implementation | @vexcms/convex, fields, hooks | Forms work, data persists |
| D | CLI tool | create-vexcms | `pnpm create vexcms` works |

Start with Phase A, validate, then proceed incrementally.
